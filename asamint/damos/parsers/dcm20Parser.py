# Generated from dcm20.g4 by ANTLR 4.8
import sys
from io import StringIO

from antlr4 import *


if sys.version_info[1] > 5:
    from typing import TextIO
else:
    from typing.io import TextIO


def serializedATN():
    with StringIO() as buf:
        buf.write("\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3+")
        buf.write("\u01e4\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7")
        buf.write("\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r\4\16")
        buf.write("\t\16\4\17\t\17\4\20\t\20\4\21\t\21\4\22\t\22\4\23\t\23")
        buf.write("\4\24\t\24\4\25\t\25\4\26\t\26\4\27\t\27\4\30\t\30\4\31")
        buf.write("\t\31\4\32\t\32\4\33\t\33\4\34\t\34\4\35\t\35\4\36\t\36")
        buf.write('\4\37\t\37\4 \t \4!\t!\4"\t"\4#\t#\4$\t$\4%\t%\4&\t')
        buf.write("&\4'\t'\4(\t(\4)\t)\4*\t*\4+\t+\4,\t,\4-\t-\4.\t.\3")
        buf.write("\2\7\2^\n\2\f\2\16\2a\13\2\3\2\3\2\3\2\6\2f\n\2\r\2\16")
        buf.write("\2g\3\2\3\2\3\2\3\3\5\3n\n\3\3\3\5\3q\n\3\3\3\5\3t\n\3")
        buf.write("\3\4\6\4w\n\4\r\4\16\4x\3\5\3\5\7\5}\n\5\f\5\16\5\u0080")
        buf.write("\13\5\3\6\3\6\3\6\3\6\3\7\3\7\3\7\3\b\3\b\3\t\3\t\6\t")
        buf.write("\u008d\n\t\r\t\16\t\u008e\3\n\3\n\3\n\6\n\u0094\n\n\r")
        buf.write("\n\16\n\u0095\3\n\3\n\6\n\u009a\n\n\r\n\16\n\u009b\3\13")
        buf.write("\3\13\3\13\3\13\3\13\3\f\3\f\3\r\3\r\6\r\u00a7\n\r\r\r")
        buf.write("\16\r\u00a8\3\16\3\16\3\16\6\16\u00ae\n\16\r\16\16\16")
        buf.write("\u00af\3\16\3\16\6\16\u00b4\n\16\r\16\16\16\u00b5\3\17")
        buf.write("\3\17\3\17\7\17\u00bb\n\17\f\17\16\17\u00be\13\17\3\17")
        buf.write("\6\17\u00c1\n\17\r\17\16\17\u00c2\3\20\3\20\3\21\3\21")
        buf.write("\3\22\7\22\u00ca\n\22\f\22\16\22\u00cd\13\22\3\23\3\23")
        buf.write("\3\23\3\23\3\23\3\23\5\23\u00d5\n\23\3\24\3\24\3\24\3")
        buf.write("\24\3\24\5\24\u00dc\n\24\3\24\3\24\3\24\3\24\5\24\u00e2")
        buf.write("\n\24\3\24\3\24\3\24\6\24\u00e7\n\24\r\24\16\24\u00e8")
        buf.write("\3\25\3\25\3\25\3\25\3\25\3\25\5\25\u00f1\n\25\3\25\6")
        buf.write("\25\u00f4\n\25\r\25\16\25\u00f5\3\25\3\25\6\25\u00fa\n")
        buf.write("\25\r\25\16\25\u00fb\3\26\3\26\3\26\3\26\3\26\3\26\5\26")
        buf.write("\u0104\n\26\3\26\5\26\u0107\n\26\3\26\6\26\u010a\n\26")
        buf.write("\r\26\16\26\u010b\3\26\6\26\u010f\n\26\r\26\16\26\u0110")
        buf.write("\3\26\3\26\6\26\u0115\n\26\r\26\16\26\u0116\3\27\3\27")
        buf.write("\3\27\3\27\3\27\3\27\3\27\5\27\u0120\n\27\3\27\5\27\u0123")
        buf.write("\n\27\3\27\5\27\u0126\n\27\3\27\6\27\u0129\n\27\r\27\16")
        buf.write("\27\u012a\3\27\3\27\3\27\6\27\u0130\n\27\r\27\16\27\u0131")
        buf.write("\3\30\3\30\3\30\3\30\3\30\3\30\5\30\u013a\n\30\3\30\6")
        buf.write("\30\u013d\n\30\r\30\16\30\u013e\3\30\3\30\6\30\u0143\n")
        buf.write("\30\r\30\16\30\u0144\3\31\3\31\3\31\3\31\3\31\3\31\3\31")
        buf.write("\3\31\3\31\6\31\u0150\n\31\r\31\16\31\u0151\3\32\5\32")
        buf.write("\u0155\n\32\3\32\5\32\u0158\n\32\3\32\5\32\u015b\n\32")
        buf.write("\3\32\5\32\u015e\n\32\3\33\3\33\3\33\3\33\3\34\3\34\3")
        buf.write("\34\3\34\3\35\3\35\3\35\3\35\3\36\3\36\3\36\3\36\3\37")
        buf.write("\3\37\3\37\5\37\u0173\n\37\3\37\3\37\3 \3 \3 \3 \7 \u017b")
        buf.write('\n \f \16 \u017e\13 \3 \3 \3!\3!\3!\3!\3"\3"\6"\u0188')
        buf.write('\n"\r"\16"\u0189\3"\3"\3#\3#\3$\3$\3%\3%\6%\u0194')
        buf.write("\n%\r%\16%\u0195\3%\3%\3&\3&\6&\u019c\n&\r&\16&\u019d")
        buf.write("\3&\3&\3&\3&\6&\u01a4\n&\r&\16&\u01a5\3&\3&\5&\u01aa\n")
        buf.write("&\3'\3'\6'\u01ae\n'\r'\16'\u01af\3'\3'\3'\3'")
        buf.write("\6'\u01b6\n'\r'\16'\u01b7\3'\3'\5'\u01bc\n'\3")
        buf.write("(\6(\u01bf\n(\r(\16(\u01c0\3(\6(\u01c4\n(\r(\16(\u01c5")
        buf.write("\5(\u01c8\n(\3)\3)\3)\3)\6)\u01ce\n)\r)\16)\u01cf\3*\3")
        buf.write("*\3*\3*\6*\u01d6\n*\r*\16*\u01d7\3+\3+\5+\u01dc\n+\3,")
        buf.write("\3,\3-\3-\3.\3.\3.\2\2/\2\4\6\b\n\f\16\20\22\24\26\30")
        buf.write('\32\34\36 "$&(*,.\60\62\64\668:<>@BDFHJLNPRTVXZ\2\4\3')
        buf.write("\2\20\22\3\2\23\25\2\u01f3\2_\3\2\2\2\4m\3\2\2\2\6v\3")
        buf.write("\2\2\2\bz\3\2\2\2\n\u0081\3\2\2\2\f\u0085\3\2\2\2\16\u0088")
        buf.write("\3\2\2\2\20\u008a\3\2\2\2\22\u0090\3\2\2\2\24\u009d\3")
        buf.write("\2\2\2\26\u00a2\3\2\2\2\30\u00a4\3\2\2\2\32\u00aa\3\2")
        buf.write("\2\2\34\u00b7\3\2\2\2\36\u00c4\3\2\2\2 \u00c6\3\2\2\2")
        buf.write('"\u00cb\3\2\2\2$\u00d4\3\2\2\2&\u00d6\3\2\2\2(\u00ea')
        buf.write("\3\2\2\2*\u00fd\3\2\2\2,\u0118\3\2\2\2.\u0133\3\2\2\2")
        buf.write("\60\u0146\3\2\2\2\62\u0154\3\2\2\2\64\u015f\3\2\2\2\66")
        buf.write("\u0163\3\2\2\28\u0167\3\2\2\2:\u016b\3\2\2\2<\u016f\3")
        buf.write("\2\2\2>\u0176\3\2\2\2@\u0181\3\2\2\2B\u0185\3\2\2\2D\u018d")
        buf.write("\3\2\2\2F\u018f\3\2\2\2H\u0191\3\2\2\2J\u01a9\3\2\2\2")
        buf.write("L\u01bb\3\2\2\2N\u01c7\3\2\2\2P\u01c9\3\2\2\2R\u01d1\3")
        buf.write("\2\2\2T\u01db\3\2\2\2V\u01dd\3\2\2\2X\u01df\3\2\2\2Z\u01e1")
        buf.write("\3\2\2\2\\^\7\3\2\2]\\\3\2\2\2^a\3\2\2\2_]\3\2\2\2_`\3")
        buf.write("\2\2\2`b\3\2\2\2a_\3\2\2\2bc\7\4\2\2ce\7\5\2\2df\7\3\2")
        buf.write("\2ed\3\2\2\2fg\3\2\2\2ge\3\2\2\2gh\3\2\2\2hi\3\2\2\2i")
        buf.write('j\5\4\3\2jk\5"\22\2k\3\3\2\2\2ln\5\6\4\2ml\3\2\2\2mn')
        buf.write("\3\2\2\2np\3\2\2\2oq\5\22\n\2po\3\2\2\2pq\3\2\2\2qs\3")
        buf.write("\2\2\2rt\5\32\16\2sr\3\2\2\2st\3\2\2\2t\5\3\2\2\2uw\5")
        buf.write("\b\5\2vu\3\2\2\2wx\3\2\2\2xv\3\2\2\2xy\3\2\2\2y\7\3\2")
        buf.write("\2\2z~\5\n\6\2{}\5\f\7\2|{\3\2\2\2}\u0080\3\2\2\2~|\3")
        buf.write("\2\2\2~\177\3\2\2\2\177\t\3\2\2\2\u0080~\3\2\2\2\u0081")
        buf.write("\u0082\7\6\2\2\u0082\u0083\5\16\b\2\u0083\u0084\5\20\t")
        buf.write("\2\u0084\13\3\2\2\2\u0085\u0086\7\6\2\2\u0086\u0087\5")
        buf.write("\20\t\2\u0087\r\3\2\2\2\u0088\u0089\5V,\2\u0089\17\3\2")
        buf.write("\2\2\u008a\u008c\5X-\2\u008b\u008d\7\3\2\2\u008c\u008b")
        buf.write("\3\2\2\2\u008d\u008e\3\2\2\2\u008e\u008c\3\2\2\2\u008e")
        buf.write("\u008f\3\2\2\2\u008f\21\3\2\2\2\u0090\u0091\7\7\2\2\u0091")
        buf.write("\u0093\7\3\2\2\u0092\u0094\5\24\13\2\u0093\u0092\3\2\2")
        buf.write("\2\u0094\u0095\3\2\2\2\u0095\u0093\3\2\2\2\u0095\u0096")
        buf.write("\3\2\2\2\u0096\u0097\3\2\2\2\u0097\u0099\7\b\2\2\u0098")
        buf.write("\u009a\7\3\2\2\u0099\u0098\3\2\2\2\u009a\u009b\3\2\2\2")
        buf.write("\u009b\u0099\3\2\2\2\u009b\u009c\3\2\2\2\u009c\23\3\2")
        buf.write("\2\2\u009d\u009e\7\t\2\2\u009e\u009f\5V,\2\u009f\u00a0")
        buf.write("\5\26\f\2\u00a0\u00a1\5\30\r\2\u00a1\25\3\2\2\2\u00a2")
        buf.write("\u00a3\5X-\2\u00a3\27\3\2\2\2\u00a4\u00a6\5X-\2\u00a5")
        buf.write("\u00a7\7\3\2\2\u00a6\u00a5\3\2\2\2\u00a7\u00a8\3\2\2\2")
        buf.write("\u00a8\u00a6\3\2\2\2\u00a8\u00a9\3\2\2\2\u00a9\31\3\2")
        buf.write("\2\2\u00aa\u00ab\7\n\2\2\u00ab\u00ad\7\3\2\2\u00ac\u00ae")
        buf.write("\5\34\17\2\u00ad\u00ac\3\2\2\2\u00ae\u00af\3\2\2\2\u00af")
        buf.write("\u00ad\3\2\2\2\u00af\u00b0\3\2\2\2\u00b0\u00b1\3\2\2\2")
        buf.write("\u00b1\u00b3\7\b\2\2\u00b2\u00b4\7\3\2\2\u00b3\u00b2\3")
        buf.write("\2\2\2\u00b4\u00b5\3\2\2\2\u00b5\u00b3\3\2\2\2\u00b5\u00b6")
        buf.write("\3\2\2\2\u00b6\33\3\2\2\2\u00b7\u00b8\7\13\2\2\u00b8\u00bc")
        buf.write("\5\36\20\2\u00b9\u00bb\5 \21\2\u00ba\u00b9\3\2\2\2\u00bb")
        buf.write("\u00be\3\2\2\2\u00bc\u00ba\3\2\2\2\u00bc\u00bd\3\2\2\2")
        buf.write("\u00bd\u00c0\3\2\2\2\u00be\u00bc\3\2\2\2\u00bf\u00c1\7")
        buf.write("\3\2\2\u00c0\u00bf\3\2\2\2\u00c1\u00c2\3\2\2\2\u00c2\u00c0")
        buf.write("\3\2\2\2\u00c2\u00c3\3\2\2\2\u00c3\35\3\2\2\2\u00c4\u00c5")
        buf.write("\5V,\2\u00c5\37\3\2\2\2\u00c6\u00c7\5V,\2\u00c7!\3\2\2")
        buf.write("\2\u00c8\u00ca\5$\23\2\u00c9\u00c8\3\2\2\2\u00ca\u00cd")
        buf.write("\3\2\2\2\u00cb\u00c9\3\2\2\2\u00cb\u00cc\3\2\2\2\u00cc")
        buf.write("#\3\2\2\2\u00cd\u00cb\3\2\2\2\u00ce\u00d5\5&\24\2\u00cf")
        buf.write("\u00d5\5(\25\2\u00d0\u00d5\5*\26\2\u00d1\u00d5\5,\27\2")
        buf.write("\u00d2\u00d5\5.\30\2\u00d3\u00d5\5\60\31\2\u00d4\u00ce")
        buf.write("\3\2\2\2\u00d4\u00cf\3\2\2\2\u00d4\u00d0\3\2\2\2\u00d4")
        buf.write("\u00d1\3\2\2\2\u00d4\u00d2\3\2\2\2\u00d4\u00d3\3\2\2\2")
        buf.write("\u00d5%\3\2\2\2\u00d6\u00d7\7\f\2\2\u00d7\u00d8\5V,\2")
        buf.write("\u00d8\u00d9\7\3\2\2\u00d9\u00db\5\62\32\2\u00da\u00dc")
        buf.write("\58\35\2\u00db\u00da\3\2\2\2\u00db\u00dc\3\2\2\2\u00dc")
        buf.write("\u00e1\3\2\2\2\u00dd\u00de\7\r\2\2\u00de\u00e2\5T+\2\u00df")
        buf.write("\u00e0\7\16\2\2\u00e0\u00e2\5X-\2\u00e1\u00dd\3\2\2\2")
        buf.write("\u00e1\u00df\3\2\2\2\u00e2\u00e3\3\2\2\2\u00e3\u00e4\7")
        buf.write("\3\2\2\u00e4\u00e6\7\b\2\2\u00e5\u00e7\7\3\2\2\u00e6\u00e5")
        buf.write("\3\2\2\2\u00e7\u00e8\3\2\2\2\u00e8\u00e6\3\2\2\2\u00e8")
        buf.write("\u00e9\3\2\2\2\u00e9'\3\2\2\2\u00ea\u00eb\7\17\2\2\u00eb")
        buf.write("\u00ec\5V,\2\u00ec\u00ed\5D#\2\u00ed\u00ee\7\3\2\2\u00ee")
        buf.write("\u00f0\5\62\32\2\u00ef\u00f1\58\35\2\u00f0\u00ef\3\2\2")
        buf.write("\2\u00f0\u00f1\3\2\2\2\u00f1\u00f3\3\2\2\2\u00f2\u00f4")
        buf.write("\5J&\2\u00f3\u00f2\3\2\2\2\u00f4\u00f5\3\2\2\2\u00f5\u00f3")
        buf.write("\3\2\2\2\u00f5\u00f6\3\2\2\2\u00f6\u00f7\3\2\2\2\u00f7")
        buf.write("\u00f9\7\b\2\2\u00f8\u00fa\7\3\2\2\u00f9\u00f8\3\2\2\2")
        buf.write("\u00fa\u00fb\3\2\2\2\u00fb\u00f9\3\2\2\2\u00fb\u00fc\3")
        buf.write("\2\2\2\u00fc)\3\2\2\2\u00fd\u00fe\t\2\2\2\u00fe\u00ff")
        buf.write("\5V,\2\u00ff\u0100\5D#\2\u0100\u0101\7\3\2\2\u0101\u0103")
        buf.write("\5\62\32\2\u0102\u0104\5\64\33\2\u0103\u0102\3\2\2\2\u0103")
        buf.write("\u0104\3\2\2\2\u0104\u0106\3\2\2\2\u0105\u0107\58\35\2")
        buf.write("\u0106\u0105\3\2\2\2\u0106\u0107\3\2\2\2\u0107\u0109\3")
        buf.write("\2\2\2\u0108\u010a\5L'\2\u0109\u0108\3\2\2\2\u010a\u010b")
        buf.write("\3\2\2\2\u010b\u0109\3\2\2\2\u010b\u010c\3\2\2\2\u010c")
        buf.write("\u010e\3\2\2\2\u010d\u010f\5H%\2\u010e\u010d\3\2\2\2\u010f")
        buf.write("\u0110\3\2\2\2\u0110\u010e\3\2\2\2\u0110\u0111\3\2\2\2")
        buf.write("\u0111\u0112\3\2\2\2\u0112\u0114\7\b\2\2\u0113\u0115\7")
        buf.write("\3\2\2\u0114\u0113\3\2\2\2\u0115\u0116\3\2\2\2\u0116\u0114")
        buf.write("\3\2\2\2\u0116\u0117\3\2\2\2\u0117+\3\2\2\2\u0118\u0119")
        buf.write("\t\3\2\2\u0119\u011a\5V,\2\u011a\u011b\5D#\2\u011b\u011c")
        buf.write("\5F$\2\u011c\u011d\7\3\2\2\u011d\u011f\5\62\32\2\u011e")
        buf.write("\u0120\5\64\33\2\u011f\u011e\3\2\2\2\u011f\u0120\3\2\2")
        buf.write("\2\u0120\u0122\3\2\2\2\u0121\u0123\5\66\34\2\u0122\u0121")
        buf.write("\3\2\2\2\u0122\u0123\3\2\2\2\u0123\u0125\3\2\2\2\u0124")
        buf.write("\u0126\58\35\2\u0125\u0124\3\2\2\2\u0125\u0126\3\2\2\2")
        buf.write("\u0126\u0128\3\2\2\2\u0127\u0129\5L'\2\u0128\u0127\3")
        buf.write("\2\2\2\u0129\u012a\3\2\2\2\u012a\u0128\3\2\2\2\u012a\u012b")
        buf.write("\3\2\2\2\u012b\u012c\3\2\2\2\u012c\u012d\5N(\2\u012d\u012f")
        buf.write("\7\b\2\2\u012e\u0130\7\3\2\2\u012f\u012e\3\2\2\2\u0130")
        buf.write("\u0131\3\2\2\2\u0131\u012f\3\2\2\2\u0131\u0132\3\2\2\2")
        buf.write("\u0132-\3\2\2\2\u0133\u0134\7\26\2\2\u0134\u0135\5V,\2")
        buf.write("\u0135\u0136\5D#\2\u0136\u0137\7\3\2\2\u0137\u0139\5\62")
        buf.write("\32\2\u0138\u013a\5\64\33\2\u0139\u0138\3\2\2\2\u0139")
        buf.write("\u013a\3\2\2\2\u013a\u013c\3\2\2\2\u013b\u013d\5L'\2")
        buf.write("\u013c\u013b\3\2\2\2\u013d\u013e\3\2\2\2\u013e\u013c\3")
        buf.write("\2\2\2\u013e\u013f\3\2\2\2\u013f\u0140\3\2\2\2\u0140\u0142")
        buf.write("\7\b\2\2\u0141\u0143\7\3\2\2\u0142\u0141\3\2\2\2\u0143")
        buf.write("\u0144\3\2\2\2\u0144\u0142\3\2\2\2\u0144\u0145\3\2\2\2")
        buf.write("\u0145/\3\2\2\2\u0146\u0147\7\27\2\2\u0147\u0148\5V,\2")
        buf.write("\u0148\u0149\7\3\2\2\u0149\u014a\5\62\32\2\u014a\u014b")
        buf.write("\7\16\2\2\u014b\u014c\5X-\2\u014c\u014d\7\3\2\2\u014d")
        buf.write("\u014f\7\b\2\2\u014e\u0150\7\3\2\2\u014f\u014e\3\2\2\2")
        buf.write("\u0150\u0151\3\2\2\2\u0151\u014f\3\2\2\2\u0151\u0152\3")
        buf.write("\2\2\2\u0152\61\3\2\2\2\u0153\u0155\5:\36\2\u0154\u0153")
        buf.write("\3\2\2\2\u0154\u0155\3\2\2\2\u0155\u0157\3\2\2\2\u0156")
        buf.write("\u0158\5<\37\2\u0157\u0156\3\2\2\2\u0157\u0158\3\2\2\2")
        buf.write("\u0158\u015a\3\2\2\2\u0159\u015b\5> \2\u015a\u0159\3\2")
        buf.write("\2\2\u015a\u015b\3\2\2\2\u015b\u015d\3\2\2\2\u015c\u015e")
        buf.write('\5B"\2\u015d\u015c\3\2\2\2\u015d\u015e\3\2\2\2\u015e')
        buf.write("\63\3\2\2\2\u015f\u0160\7\30\2\2\u0160\u0161\5X-\2\u0161")
        buf.write("\u0162\7\3\2\2\u0162\65\3\2\2\2\u0163\u0164\7\31\2\2\u0164")
        buf.write("\u0165\5X-\2\u0165\u0166\7\3\2\2\u0166\67\3\2\2\2\u0167")
        buf.write("\u0168\7\32\2\2\u0168\u0169\5X-\2\u0169\u016a\7\3\2\2")
        buf.write("\u016a9\3\2\2\2\u016b\u016c\7\33\2\2\u016c\u016d\5X-\2")
        buf.write("\u016d\u016e\7\3\2\2\u016e;\3\2\2\2\u016f\u0172\7\34\2")
        buf.write("\2\u0170\u0173\5V,\2\u0171\u0173\5X-\2\u0172\u0170\3\2")
        buf.write("\2\2\u0172\u0171\3\2\2\2\u0173\u0174\3\2\2\2\u0174\u0175")
        buf.write("\7\3\2\2\u0175=\3\2\2\2\u0176\u0177\7\35\2\2\u0177\u017c")
        buf.write("\5@!\2\u0178\u0179\7\36\2\2\u0179\u017b\5@!\2\u017a\u0178")
        buf.write("\3\2\2\2\u017b\u017e\3\2\2\2\u017c\u017a\3\2\2\2\u017c")
        buf.write("\u017d\3\2\2\2\u017d\u017f\3\2\2\2\u017e\u017c\3\2\2\2")
        buf.write("\u017f\u0180\7\3\2\2\u0180?\3\2\2\2\u0181\u0182\7%\2\2")
        buf.write("\u0182\u0183\7\37\2\2\u0183\u0184\5V,\2\u0184A\3\2\2\2")
        buf.write("\u0185\u0187\7 \2\2\u0186\u0188\5V,\2\u0187\u0186\3\2")
        buf.write("\2\2\u0188\u0189\3\2\2\2\u0189\u0187\3\2\2\2\u0189\u018a")
        buf.write("\3\2\2\2\u018a\u018b\3\2\2\2\u018b\u018c\7\3\2\2\u018c")
        buf.write("C\3\2\2\2\u018d\u018e\5Z.\2\u018eE\3\2\2\2\u018f\u0190")
        buf.write("\5Z.\2\u0190G\3\2\2\2\u0191\u0193\7\r\2\2\u0192\u0194")
        buf.write("\5T+\2\u0193\u0192\3\2\2\2\u0194\u0195\3\2\2\2\u0195\u0193")
        buf.write("\3\2\2\2\u0195\u0196\3\2\2\2\u0196\u0197\3\2\2\2\u0197")
        buf.write("\u0198\7\3\2\2\u0198I\3\2\2\2\u0199\u019b\7\r\2\2\u019a")
        buf.write("\u019c\5T+\2\u019b\u019a\3\2\2\2\u019c\u019d\3\2\2\2\u019d")
        buf.write("\u019b\3\2\2\2\u019d\u019e\3\2\2\2\u019e\u019f\3\2\2\2")
        buf.write("\u019f\u01a0\7\3\2\2\u01a0\u01aa\3\2\2\2\u01a1\u01a3\7")
        buf.write("\16\2\2\u01a2\u01a4\5X-\2\u01a3\u01a2\3\2\2\2\u01a4\u01a5")
        buf.write("\3\2\2\2\u01a5\u01a3\3\2\2\2\u01a5\u01a6\3\2\2\2\u01a6")
        buf.write("\u01a7\3\2\2\2\u01a7\u01a8\7\3\2\2\u01a8\u01aa\3\2\2\2")
        buf.write("\u01a9\u0199\3\2\2\2\u01a9\u01a1\3\2\2\2\u01aaK\3\2\2")
        buf.write("\2\u01ab\u01ad\7!\2\2\u01ac\u01ae\5T+\2\u01ad\u01ac\3")
        buf.write("\2\2\2\u01ae\u01af\3\2\2\2\u01af\u01ad\3\2\2\2\u01af\u01b0")
        buf.write("\3\2\2\2\u01b0\u01b1\3\2\2\2\u01b1\u01b2\7\3\2\2\u01b2")
        buf.write('\u01bc\3\2\2\2\u01b3\u01b5\7"\2\2\u01b4\u01b6\5X-\2\u01b5')
        buf.write("\u01b4\3\2\2\2\u01b6\u01b7\3\2\2\2\u01b7\u01b5\3\2\2\2")
        buf.write("\u01b7\u01b8\3\2\2\2\u01b8\u01b9\3\2\2\2\u01b9\u01ba\7")
        buf.write("\3\2\2\u01ba\u01bc\3\2\2\2\u01bb\u01ab\3\2\2\2\u01bb\u01b3")
        buf.write("\3\2\2\2\u01bcM\3\2\2\2\u01bd\u01bf\5P)\2\u01be\u01bd")
        buf.write("\3\2\2\2\u01bf\u01c0\3\2\2\2\u01c0\u01be\3\2\2\2\u01c0")
        buf.write("\u01c1\3\2\2\2\u01c1\u01c8\3\2\2\2\u01c2\u01c4\5R*\2\u01c3")
        buf.write("\u01c2\3\2\2\2\u01c4\u01c5\3\2\2\2\u01c5\u01c3\3\2\2\2")
        buf.write("\u01c5\u01c6\3\2\2\2\u01c6\u01c8\3\2\2\2\u01c7\u01be\3")
        buf.write("\2\2\2\u01c7\u01c3\3\2\2\2\u01c8O\3\2\2\2\u01c9\u01ca")
        buf.write("\7#\2\2\u01ca\u01cb\5T+\2\u01cb\u01cd\7\3\2\2\u01cc\u01ce")
        buf.write("\5H%\2\u01cd\u01cc\3\2\2\2\u01ce\u01cf\3\2\2\2\u01cf\u01cd")
        buf.write("\3\2\2\2\u01cf\u01d0\3\2\2\2\u01d0Q\3\2\2\2\u01d1\u01d2")
        buf.write("\7$\2\2\u01d2\u01d3\5X-\2\u01d3\u01d5\7\3\2\2\u01d4\u01d6")
        buf.write("\5H%\2\u01d5\u01d4\3\2\2\2\u01d6\u01d7\3\2\2\2\u01d7\u01d5")
        buf.write("\3\2\2\2\u01d7\u01d8\3\2\2\2\u01d8S\3\2\2\2\u01d9\u01dc")
        buf.write("\7'\2\2\u01da\u01dc\7(\2\2\u01db\u01d9\3\2\2\2\u01db")
        buf.write("\u01da\3\2\2\2\u01dcU\3\2\2\2\u01dd\u01de\7%\2\2\u01de")
        buf.write("W\3\2\2\2\u01df\u01e0\7&\2\2\u01e0Y\3\2\2\2\u01e1\u01e2")
        buf.write("\7'\2\2\u01e2[\3\2\2\2;_gmpsx~\u008e\u0095\u009b\u00a8")
        buf.write("\u00af\u00b5\u00bc\u00c2\u00cb\u00d4\u00db\u00e1\u00e8")
        buf.write("\u00f0\u00f5\u00fb\u0103\u0106\u010b\u0110\u0116\u011f")
        buf.write("\u0122\u0125\u012a\u0131\u0139\u013e\u0144\u0151\u0154")
        buf.write("\u0157\u015a\u015d\u0172\u017c\u0189\u0195\u019d\u01a5")
        buf.write("\u01a9\u01af\u01b7\u01bb\u01c0\u01c5\u01c7\u01cf\u01d7")
        buf.write("\u01db")
        return buf.getvalue()


class dcm20Parser(Parser):

    grammarFileName = "dcm20.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [DFA(ds, i) for i, ds in enumerate(atn.decisionToState)]

    sharedContextCache = PredictionContextCache()

    literalNames = [
        "<INVALID>",
        "'\n'",
        "'KONSERVIERUNG_FORMAT'",
        "'2.0'",
        "'MODULKOPF'",
        "'FUNKTIONEN'",
        "'END'",
        "'FKT'",
        "'VARIANTENKODIERUNG'",
        "'KRITERIUM'",
        "'FESTWERT'",
        "'WERT'",
        "'TEXT'",
        "'FESTWERTEBLOCK'",
        "'KENNLINIE'",
        "'FESTKENNLINIE'",
        "'GRUPPENKENNLINIE'",
        "'KENNFELD'",
        "'FESTKENNFELD'",
        "'GRUPPENKENNFELD'",
        "'STUETZSTELLENVERTEILUNG'",
        "'TEXTSTRING'",
        "'EINHEIT_X'",
        "'EINHEIT_Y'",
        "'EINHEIT_W'",
        "'LANGNAME'",
        "'DISPLAYNAME'",
        "'VAR'",
        "','",
        "'='",
        "'FUNKTION'",
        "'ST/X'",
        "'ST_TX/X'",
        "'ST/Y'",
        "'ST_TX/Y'",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "'-'",
    ]

    symbolicNames = [
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "<INVALID>",
        "NAME",
        "TEXT",
        "INT",
        "FLOAT",
        "MINUS",
        "WS",
        "COMMENT",
    ]

    RULE_konservierung = 0
    RULE_kons_kopf = 1
    RULE_modulkopf_info = 2
    RULE_mod_zeile = 3
    RULE_mod_anf_zeile = 4
    RULE_mod_fort_zeile = 5
    RULE_mod_ele_name = 6
    RULE_mod_ele_wert = 7
    RULE_funktionsdef = 8
    RULE_funktionszeile = 9
    RULE_fkt_version = 10
    RULE_fkt_langname = 11
    RULE_variantendef = 12
    RULE_variantenkrit = 13
    RULE_krit_name = 14
    RULE_krit_wert = 15
    RULE_kons_rumpf = 16
    RULE_kenngroesse = 17
    RULE_kennwert = 18
    RULE_kennwerteblock = 19
    RULE_kennlinie = 20
    RULE_kennfeld = 21
    RULE_gruppenstuetzstellen = 22
    RULE_kenntext = 23
    RULE_kgr_info = 24
    RULE_einheit_x = 25
    RULE_einheit_y = 26
    RULE_einheit_w = 27
    RULE_langname = 28
    RULE_displayname = 29
    RULE_var_abhangigkeiten = 30
    RULE_var_abh = 31
    RULE_funktionszugehorigkeit = 32
    RULE_anzahl_x = 33
    RULE_anzahl_y = 34
    RULE_werteliste = 35
    RULE_werteliste_kwb = 36
    RULE_sst_liste_x = 37
    RULE_kf_zeile_liste = 38
    RULE_kf_zeile_liste_r = 39
    RULE_kf_zeile_liste_tx = 40
    RULE_realzahl = 41
    RULE_nameValue = 42
    RULE_textValue = 43
    RULE_integerValue = 44

    ruleNames = [
        "konservierung",
        "kons_kopf",
        "modulkopf_info",
        "mod_zeile",
        "mod_anf_zeile",
        "mod_fort_zeile",
        "mod_ele_name",
        "mod_ele_wert",
        "funktionsdef",
        "funktionszeile",
        "fkt_version",
        "fkt_langname",
        "variantendef",
        "variantenkrit",
        "krit_name",
        "krit_wert",
        "kons_rumpf",
        "kenngroesse",
        "kennwert",
        "kennwerteblock",
        "kennlinie",
        "kennfeld",
        "gruppenstuetzstellen",
        "kenntext",
        "kgr_info",
        "einheit_x",
        "einheit_y",
        "einheit_w",
        "langname",
        "displayname",
        "var_abhangigkeiten",
        "var_abh",
        "funktionszugehorigkeit",
        "anzahl_x",
        "anzahl_y",
        "werteliste",
        "werteliste_kwb",
        "sst_liste_x",
        "kf_zeile_liste",
        "kf_zeile_liste_r",
        "kf_zeile_liste_tx",
        "realzahl",
        "nameValue",
        "textValue",
        "integerValue",
    ]

    EOF = Token.EOF
    T__0 = 1
    T__1 = 2
    T__2 = 3
    T__3 = 4
    T__4 = 5
    T__5 = 6
    T__6 = 7
    T__7 = 8
    T__8 = 9
    T__9 = 10
    T__10 = 11
    T__11 = 12
    T__12 = 13
    T__13 = 14
    T__14 = 15
    T__15 = 16
    T__16 = 17
    T__17 = 18
    T__18 = 19
    T__19 = 20
    T__20 = 21
    T__21 = 22
    T__22 = 23
    T__23 = 24
    T__24 = 25
    T__25 = 26
    T__26 = 27
    T__27 = 28
    T__28 = 29
    T__29 = 30
    T__30 = 31
    T__31 = 32
    T__32 = 33
    T__33 = 34
    NAME = 35
    TEXT = 36
    INT = 37
    FLOAT = 38
    MINUS = 39
    WS = 40
    COMMENT = 41

    def __init__(self, input: TokenStream, output: TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.8")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None

    class KonservierungContext(ParserRuleContext):
        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.kopf = None  # Kons_kopfContext
            self.rumpf = None  # Kons_rumpfContext

        def kons_kopf(self):
            return self.getTypedRuleContext(dcm20Parser.Kons_kopfContext, 0)

        def kons_rumpf(self):
            return self.getTypedRuleContext(dcm20Parser.Kons_rumpfContext, 0)

        def getRuleIndex(self):
            return dcm20Parser.RULE_konservierung

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterKonservierung"):
                listener.enterKonservierung(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitKonservierung"):
                listener.exitKonservierung(self)

    def konservierung(self):

        localctx = dcm20Parser.KonservierungContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_konservierung)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 93
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == dcm20Parser.T__0:
                self.state = 90
                self.match(dcm20Parser.T__0)
                self.state = 95
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 96
            self.match(dcm20Parser.T__1)
            self.state = 97
            self.match(dcm20Parser.T__2)
            self.state = 99
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 98
                self.match(dcm20Parser.T__0)
                self.state = 101
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la == dcm20Parser.T__0):
                    break

            self.state = 103
            localctx.kopf = self.kons_kopf()
            self.state = 104
            localctx.rumpf = self.kons_rumpf()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Kons_kopfContext(ParserRuleContext):
        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.info = None  # Modulkopf_infoContext
            self.func_def = None  # FunktionsdefContext
            self.var_def = None  # VariantendefContext

        def modulkopf_info(self):
            return self.getTypedRuleContext(dcm20Parser.Modulkopf_infoContext, 0)

        def funktionsdef(self):
            return self.getTypedRuleContext(dcm20Parser.FunktionsdefContext, 0)

        def variantendef(self):
            return self.getTypedRuleContext(dcm20Parser.VariantendefContext, 0)

        def getRuleIndex(self):
            return dcm20Parser.RULE_kons_kopf

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterKons_kopf"):
                listener.enterKons_kopf(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitKons_kopf"):
                listener.exitKons_kopf(self)

    def kons_kopf(self):

        localctx = dcm20Parser.Kons_kopfContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_kons_kopf)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 107
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == dcm20Parser.T__3:
                self.state = 106
                localctx.info = self.modulkopf_info()

            self.state = 110
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == dcm20Parser.T__4:
                self.state = 109
                localctx.func_def = self.funktionsdef()

            self.state = 113
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == dcm20Parser.T__7:
                self.state = 112
                localctx.var_def = self.variantendef()

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Modulkopf_infoContext(ParserRuleContext):
        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self._mod_zeile = None  # Mod_zeileContext
            self.m = list()  # of Mod_zeileContexts

        def mod_zeile(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(dcm20Parser.Mod_zeileContext)
            else:
                return self.getTypedRuleContext(dcm20Parser.Mod_zeileContext, i)

        def getRuleIndex(self):
            return dcm20Parser.RULE_modulkopf_info

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterModulkopf_info"):
                listener.enterModulkopf_info(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitModulkopf_info"):
                listener.exitModulkopf_info(self)

    def modulkopf_info(self):

        localctx = dcm20Parser.Modulkopf_infoContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_modulkopf_info)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 116
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 115
                localctx._mod_zeile = self.mod_zeile()
                localctx.m.append(localctx._mod_zeile)
                self.state = 118
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la == dcm20Parser.T__3):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Mod_zeileContext(ParserRuleContext):
        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.anf = None  # Mod_anf_zeileContext
            self._mod_fort_zeile = None  # Mod_fort_zeileContext
            self.fort = list()  # of Mod_fort_zeileContexts

        def mod_anf_zeile(self):
            return self.getTypedRuleContext(dcm20Parser.Mod_anf_zeileContext, 0)

        def mod_fort_zeile(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(dcm20Parser.Mod_fort_zeileContext)
            else:
                return self.getTypedRuleContext(dcm20Parser.Mod_fort_zeileContext, i)

        def getRuleIndex(self):
            return dcm20Parser.RULE_mod_zeile

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterMod_zeile"):
                listener.enterMod_zeile(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitMod_zeile"):
                listener.exitMod_zeile(self)

    def mod_zeile(self):

        localctx = dcm20Parser.Mod_zeileContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_mod_zeile)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 120
            localctx.anf = self.mod_anf_zeile()
            self.state = 124
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input, 6, self._ctx)
            while _alt != 2 and _alt != ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 121
                    localctx._mod_fort_zeile = self.mod_fort_zeile()
                    localctx.fort.append(localctx._mod_fort_zeile)
                self.state = 126
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input, 6, self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Mod_anf_zeileContext(ParserRuleContext):
        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.n = None  # Mod_ele_nameContext
            self.w = None  # Mod_ele_wertContext

        def mod_ele_name(self):
            return self.getTypedRuleContext(dcm20Parser.Mod_ele_nameContext, 0)

        def mod_ele_wert(self):
            return self.getTypedRuleContext(dcm20Parser.Mod_ele_wertContext, 0)

        def getRuleIndex(self):
            return dcm20Parser.RULE_mod_anf_zeile

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterMod_anf_zeile"):
                listener.enterMod_anf_zeile(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitMod_anf_zeile"):
                listener.exitMod_anf_zeile(self)

    def mod_anf_zeile(self):

        localctx = dcm20Parser.Mod_anf_zeileContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_mod_anf_zeile)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 127
            self.match(dcm20Parser.T__3)
            self.state = 128
            localctx.n = self.mod_ele_name()
            self.state = 129
            localctx.w = self.mod_ele_wert()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Mod_fort_zeileContext(ParserRuleContext):
        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.w = None  # Mod_ele_wertContext

        def mod_ele_wert(self):
            return self.getTypedRuleContext(dcm20Parser.Mod_ele_wertContext, 0)

        def getRuleIndex(self):
            return dcm20Parser.RULE_mod_fort_zeile

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterMod_fort_zeile"):
                listener.enterMod_fort_zeile(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitMod_fort_zeile"):
                listener.exitMod_fort_zeile(self)

    def mod_fort_zeile(self):

        localctx = dcm20Parser.Mod_fort_zeileContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_mod_fort_zeile)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 131
            self.match(dcm20Parser.T__3)
            self.state = 132
            localctx.w = self.mod_ele_wert()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Mod_ele_nameContext(ParserRuleContext):
        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.n = None  # NameValueContext

        def nameValue(self):
            return self.getTypedRuleContext(dcm20Parser.NameValueContext, 0)

        def getRuleIndex(self):
            return dcm20Parser.RULE_mod_ele_name

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterMod_ele_name"):
                listener.enterMod_ele_name(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitMod_ele_name"):
                listener.exitMod_ele_name(self)

    def mod_ele_name(self):

        localctx = dcm20Parser.Mod_ele_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_mod_ele_name)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 134
            localctx.n = self.nameValue()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Mod_ele_wertContext(ParserRuleContext):
        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.t = None  # TextValueContext

        def textValue(self):
            return self.getTypedRuleContext(dcm20Parser.TextValueContext, 0)

        def getRuleIndex(self):
            return dcm20Parser.RULE_mod_ele_wert

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterMod_ele_wert"):
                listener.enterMod_ele_wert(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitMod_ele_wert"):
                listener.exitMod_ele_wert(self)

    def mod_ele_wert(self):

        localctx = dcm20Parser.Mod_ele_wertContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_mod_ele_wert)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 136
            localctx.t = self.textValue()
            self.state = 138
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 137
                self.match(dcm20Parser.T__0)
                self.state = 140
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la == dcm20Parser.T__0):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class FunktionsdefContext(ParserRuleContext):
        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self._funktionszeile = None  # FunktionszeileContext
            self.f = list()  # of FunktionszeileContexts

        def funktionszeile(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(dcm20Parser.FunktionszeileContext)
            else:
                return self.getTypedRuleContext(dcm20Parser.FunktionszeileContext, i)

        def getRuleIndex(self):
            return dcm20Parser.RULE_funktionsdef

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterFunktionsdef"):
                listener.enterFunktionsdef(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitFunktionsdef"):
                listener.exitFunktionsdef(self)

    def funktionsdef(self):

        localctx = dcm20Parser.FunktionsdefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_funktionsdef)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 142
            self.match(dcm20Parser.T__4)
            self.state = 143
            self.match(dcm20Parser.T__0)
            self.state = 145
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 144
                localctx._funktionszeile = self.funktionszeile()
                localctx.f.append(localctx._funktionszeile)
                self.state = 147
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la == dcm20Parser.T__6):
                    break

            self.state = 149
            self.match(dcm20Parser.T__5)
            self.state = 151
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 150
                self.match(dcm20Parser.T__0)
                self.state = 153
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la == dcm20Parser.T__0):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class FunktionszeileContext(ParserRuleContext):
        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.n = None  # NameValueContext
            self.v = None  # Fkt_versionContext
            self.l = None  # Fkt_langnameContext

        def nameValue(self):
            return self.getTypedRuleContext(dcm20Parser.NameValueContext, 0)

        def fkt_version(self):
            return self.getTypedRuleContext(dcm20Parser.Fkt_versionContext, 0)

        def fkt_langname(self):
            return self.getTypedRuleContext(dcm20Parser.Fkt_langnameContext, 0)

        def getRuleIndex(self):
            return dcm20Parser.RULE_funktionszeile

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterFunktionszeile"):
                listener.enterFunktionszeile(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitFunktionszeile"):
                listener.exitFunktionszeile(self)

    def funktionszeile(self):

        localctx = dcm20Parser.FunktionszeileContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_funktionszeile)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 155
            self.match(dcm20Parser.T__6)
            self.state = 156
            localctx.n = self.nameValue()
            self.state = 157
            localctx.v = self.fkt_version()
            self.state = 158
            localctx.l = self.fkt_langname()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Fkt_versionContext(ParserRuleContext):
        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.t = None  # TextValueContext

        def textValue(self):
            return self.getTypedRuleContext(dcm20Parser.TextValueContext, 0)

        def getRuleIndex(self):
            return dcm20Parser.RULE_fkt_version

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterFkt_version"):
                listener.enterFkt_version(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitFkt_version"):
                listener.exitFkt_version(self)

    def fkt_version(self):

        localctx = dcm20Parser.Fkt_versionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_fkt_version)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 160
            localctx.t = self.textValue()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Fkt_langnameContext(ParserRuleContext):
        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.t = None  # TextValueContext

        def textValue(self):
            return self.getTypedRuleContext(dcm20Parser.TextValueContext, 0)

        def getRuleIndex(self):
            return dcm20Parser.RULE_fkt_langname

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterFkt_langname"):
                listener.enterFkt_langname(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitFkt_langname"):
                listener.exitFkt_langname(self)

    def fkt_langname(self):

        localctx = dcm20Parser.Fkt_langnameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_fkt_langname)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 162
            localctx.t = self.textValue()
            self.state = 164
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 163
                self.match(dcm20Parser.T__0)
                self.state = 166
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la == dcm20Parser.T__0):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class VariantendefContext(ParserRuleContext):
        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self._variantenkrit = None  # VariantenkritContext
            self.v = list()  # of VariantenkritContexts

        def variantenkrit(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(dcm20Parser.VariantenkritContext)
            else:
                return self.getTypedRuleContext(dcm20Parser.VariantenkritContext, i)

        def getRuleIndex(self):
            return dcm20Parser.RULE_variantendef

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterVariantendef"):
                listener.enterVariantendef(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitVariantendef"):
                listener.exitVariantendef(self)

    def variantendef(self):

        localctx = dcm20Parser.VariantendefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_variantendef)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 168
            self.match(dcm20Parser.T__7)
            self.state = 169
            self.match(dcm20Parser.T__0)
            self.state = 171
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 170
                localctx._variantenkrit = self.variantenkrit()
                localctx.v.append(localctx._variantenkrit)
                self.state = 173
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la == dcm20Parser.T__8):
                    break

            self.state = 175
            self.match(dcm20Parser.T__5)
            self.state = 177
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 176
                self.match(dcm20Parser.T__0)
                self.state = 179
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la == dcm20Parser.T__0):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class VariantenkritContext(ParserRuleContext):
        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.n = None  # Krit_nameContext
            self._krit_wert = None  # Krit_wertContext
            self.w = list()  # of Krit_wertContexts

        def krit_name(self):
            return self.getTypedRuleContext(dcm20Parser.Krit_nameContext, 0)

        def krit_wert(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(dcm20Parser.Krit_wertContext)
            else:
                return self.getTypedRuleContext(dcm20Parser.Krit_wertContext, i)

        def getRuleIndex(self):
            return dcm20Parser.RULE_variantenkrit

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterVariantenkrit"):
                listener.enterVariantenkrit(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitVariantenkrit"):
                listener.exitVariantenkrit(self)

    def variantenkrit(self):

        localctx = dcm20Parser.VariantenkritContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_variantenkrit)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 181
            self.match(dcm20Parser.T__8)
            self.state = 182
            localctx.n = self.krit_name()
            self.state = 186
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == dcm20Parser.NAME:
                self.state = 183
                localctx._krit_wert = self.krit_wert()
                localctx.w.append(localctx._krit_wert)
                self.state = 188
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 190
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 189
                self.match(dcm20Parser.T__0)
                self.state = 192
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la == dcm20Parser.T__0):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Krit_nameContext(ParserRuleContext):
        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.n = None  # NameValueContext

        def nameValue(self):
            return self.getTypedRuleContext(dcm20Parser.NameValueContext, 0)

        def getRuleIndex(self):
            return dcm20Parser.RULE_krit_name

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterKrit_name"):
                listener.enterKrit_name(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitKrit_name"):
                listener.exitKrit_name(self)

    def krit_name(self):

        localctx = dcm20Parser.Krit_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_krit_name)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 194
            localctx.n = self.nameValue()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Krit_wertContext(ParserRuleContext):
        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.n = None  # NameValueContext

        def nameValue(self):
            return self.getTypedRuleContext(dcm20Parser.NameValueContext, 0)

        def getRuleIndex(self):
            return dcm20Parser.RULE_krit_wert

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterKrit_wert"):
                listener.enterKrit_wert(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitKrit_wert"):
                listener.exitKrit_wert(self)

    def krit_wert(self):

        localctx = dcm20Parser.Krit_wertContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_krit_wert)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 196
            localctx.n = self.nameValue()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Kons_rumpfContext(ParserRuleContext):
        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self._kenngroesse = None  # KenngroesseContext
            self.k = list()  # of KenngroesseContexts

        def kenngroesse(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(dcm20Parser.KenngroesseContext)
            else:
                return self.getTypedRuleContext(dcm20Parser.KenngroesseContext, i)

        def getRuleIndex(self):
            return dcm20Parser.RULE_kons_rumpf

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterKons_rumpf"):
                listener.enterKons_rumpf(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitKons_rumpf"):
                listener.exitKons_rumpf(self)

    def kons_rumpf(self):

        localctx = dcm20Parser.Kons_rumpfContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_kons_rumpf)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 201
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while ((_la) & ~0x3F) == 0 and (
                (1 << _la)
                & (
                    (1 << dcm20Parser.T__9)
                    | (1 << dcm20Parser.T__12)
                    | (1 << dcm20Parser.T__13)
                    | (1 << dcm20Parser.T__14)
                    | (1 << dcm20Parser.T__15)
                    | (1 << dcm20Parser.T__16)
                    | (1 << dcm20Parser.T__17)
                    | (1 << dcm20Parser.T__18)
                    | (1 << dcm20Parser.T__19)
                    | (1 << dcm20Parser.T__20)
                )
            ) != 0:
                self.state = 198
                localctx._kenngroesse = self.kenngroesse()
                localctx.k.append(localctx._kenngroesse)
                self.state = 203
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class KenngroesseContext(ParserRuleContext):
        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.kw = None  # KennwertContext
            self.kwb = None  # KennwerteblockContext
            self.kl = None  # KennlinieContext
            self.kf = None  # KennfeldContext
            self.gst = None  # GruppenstuetzstellenContext
            self.kt = None  # KenntextContext

        def kennwert(self):
            return self.getTypedRuleContext(dcm20Parser.KennwertContext, 0)

        def kennwerteblock(self):
            return self.getTypedRuleContext(dcm20Parser.KennwerteblockContext, 0)

        def kennlinie(self):
            return self.getTypedRuleContext(dcm20Parser.KennlinieContext, 0)

        def kennfeld(self):
            return self.getTypedRuleContext(dcm20Parser.KennfeldContext, 0)

        def gruppenstuetzstellen(self):
            return self.getTypedRuleContext(dcm20Parser.GruppenstuetzstellenContext, 0)

        def kenntext(self):
            return self.getTypedRuleContext(dcm20Parser.KenntextContext, 0)

        def getRuleIndex(self):
            return dcm20Parser.RULE_kenngroesse

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterKenngroesse"):
                listener.enterKenngroesse(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitKenngroesse"):
                listener.exitKenngroesse(self)

    def kenngroesse(self):

        localctx = dcm20Parser.KenngroesseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_kenngroesse)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 210
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [dcm20Parser.T__9]:
                self.state = 204
                localctx.kw = self.kennwert()
                pass
            elif token in [dcm20Parser.T__12]:
                self.state = 205
                localctx.kwb = self.kennwerteblock()
                pass
            elif token in [dcm20Parser.T__13, dcm20Parser.T__14, dcm20Parser.T__15]:
                self.state = 206
                localctx.kl = self.kennlinie()
                pass
            elif token in [dcm20Parser.T__16, dcm20Parser.T__17, dcm20Parser.T__18]:
                self.state = 207
                localctx.kf = self.kennfeld()
                pass
            elif token in [dcm20Parser.T__19]:
                self.state = 208
                localctx.gst = self.gruppenstuetzstellen()
                pass
            elif token in [dcm20Parser.T__20]:
                self.state = 209
                localctx.kt = self.kenntext()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class KennwertContext(ParserRuleContext):
        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.n = None  # NameValueContext
            self.info = None  # Kgr_infoContext
            self.ew = None  # Einheit_wContext
            self.r = None  # RealzahlContext
            self.t = None  # TextValueContext

        def nameValue(self):
            return self.getTypedRuleContext(dcm20Parser.NameValueContext, 0)

        def kgr_info(self):
            return self.getTypedRuleContext(dcm20Parser.Kgr_infoContext, 0)

        def einheit_w(self):
            return self.getTypedRuleContext(dcm20Parser.Einheit_wContext, 0)

        def realzahl(self):
            return self.getTypedRuleContext(dcm20Parser.RealzahlContext, 0)

        def textValue(self):
            return self.getTypedRuleContext(dcm20Parser.TextValueContext, 0)

        def getRuleIndex(self):
            return dcm20Parser.RULE_kennwert

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterKennwert"):
                listener.enterKennwert(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitKennwert"):
                listener.exitKennwert(self)

    def kennwert(self):

        localctx = dcm20Parser.KennwertContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_kennwert)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 212
            self.match(dcm20Parser.T__9)
            self.state = 213
            localctx.n = self.nameValue()
            self.state = 214
            self.match(dcm20Parser.T__0)
            self.state = 215
            localctx.info = self.kgr_info()
            self.state = 217
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == dcm20Parser.T__23:
                self.state = 216
                localctx.ew = self.einheit_w()

            self.state = 223
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [dcm20Parser.T__10]:
                self.state = 219
                self.match(dcm20Parser.T__10)
                self.state = 220
                localctx.r = self.realzahl()
                pass
            elif token in [dcm20Parser.T__11]:
                self.state = 221
                self.match(dcm20Parser.T__11)
                self.state = 222
                localctx.t = self.textValue()
                pass
            else:
                raise NoViableAltException(self)

            self.state = 225
            self.match(dcm20Parser.T__0)
            self.state = 226
            self.match(dcm20Parser.T__5)
            self.state = 228
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 227
                self.match(dcm20Parser.T__0)
                self.state = 230
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la == dcm20Parser.T__0):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class KennwerteblockContext(ParserRuleContext):
        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.n = None  # NameValueContext
            self.ax = None  # Anzahl_xContext
            self.info = None  # Kgr_infoContext
            self.ew = None  # Einheit_wContext
            self._werteliste_kwb = None  # Werteliste_kwbContext
            self.w = list()  # of Werteliste_kwbContexts

        def nameValue(self):
            return self.getTypedRuleContext(dcm20Parser.NameValueContext, 0)

        def anzahl_x(self):
            return self.getTypedRuleContext(dcm20Parser.Anzahl_xContext, 0)

        def kgr_info(self):
            return self.getTypedRuleContext(dcm20Parser.Kgr_infoContext, 0)

        def einheit_w(self):
            return self.getTypedRuleContext(dcm20Parser.Einheit_wContext, 0)

        def werteliste_kwb(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(dcm20Parser.Werteliste_kwbContext)
            else:
                return self.getTypedRuleContext(dcm20Parser.Werteliste_kwbContext, i)

        def getRuleIndex(self):
            return dcm20Parser.RULE_kennwerteblock

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterKennwerteblock"):
                listener.enterKennwerteblock(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitKennwerteblock"):
                listener.exitKennwerteblock(self)

    def kennwerteblock(self):

        localctx = dcm20Parser.KennwerteblockContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_kennwerteblock)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 232
            self.match(dcm20Parser.T__12)
            self.state = 233
            localctx.n = self.nameValue()
            self.state = 234
            localctx.ax = self.anzahl_x()
            self.state = 235
            self.match(dcm20Parser.T__0)
            self.state = 236
            localctx.info = self.kgr_info()
            self.state = 238
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == dcm20Parser.T__23:
                self.state = 237
                localctx.ew = self.einheit_w()

            self.state = 241
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 240
                localctx._werteliste_kwb = self.werteliste_kwb()
                localctx.w.append(localctx._werteliste_kwb)
                self.state = 243
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la == dcm20Parser.T__10 or _la == dcm20Parser.T__11):
                    break

            self.state = 245
            self.match(dcm20Parser.T__5)
            self.state = 247
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 246
                self.match(dcm20Parser.T__0)
                self.state = 249
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la == dcm20Parser.T__0):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class KennlinieContext(ParserRuleContext):
        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.cat = None  # Token
            self.n = None  # NameValueContext
            self.ax = None  # Anzahl_xContext
            self.info = None  # Kgr_infoContext
            self.ex = None  # Einheit_xContext
            self.ew = None  # Einheit_wContext
            self._sst_liste_x = None  # Sst_liste_xContext
            self.sst = list()  # of Sst_liste_xContexts
            self._werteliste = None  # WertelisteContext
            self.wl = list()  # of WertelisteContexts

        def nameValue(self):
            return self.getTypedRuleContext(dcm20Parser.NameValueContext, 0)

        def anzahl_x(self):
            return self.getTypedRuleContext(dcm20Parser.Anzahl_xContext, 0)

        def kgr_info(self):
            return self.getTypedRuleContext(dcm20Parser.Kgr_infoContext, 0)

        def einheit_x(self):
            return self.getTypedRuleContext(dcm20Parser.Einheit_xContext, 0)

        def einheit_w(self):
            return self.getTypedRuleContext(dcm20Parser.Einheit_wContext, 0)

        def sst_liste_x(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(dcm20Parser.Sst_liste_xContext)
            else:
                return self.getTypedRuleContext(dcm20Parser.Sst_liste_xContext, i)

        def werteliste(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(dcm20Parser.WertelisteContext)
            else:
                return self.getTypedRuleContext(dcm20Parser.WertelisteContext, i)

        def getRuleIndex(self):
            return dcm20Parser.RULE_kennlinie

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterKennlinie"):
                listener.enterKennlinie(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitKennlinie"):
                listener.exitKennlinie(self)

    def kennlinie(self):

        localctx = dcm20Parser.KennlinieContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_kennlinie)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 251
            localctx.cat = self._input.LT(1)
            _la = self._input.LA(1)
            if not (
                ((_la) & ~0x3F) == 0
                and ((1 << _la) & ((1 << dcm20Parser.T__13) | (1 << dcm20Parser.T__14) | (1 << dcm20Parser.T__15))) != 0
            ):
                localctx.cat = self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 252
            localctx.n = self.nameValue()
            self.state = 253
            localctx.ax = self.anzahl_x()
            self.state = 254
            self.match(dcm20Parser.T__0)
            self.state = 255
            localctx.info = self.kgr_info()
            self.state = 257
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == dcm20Parser.T__21:
                self.state = 256
                localctx.ex = self.einheit_x()

            self.state = 260
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == dcm20Parser.T__23:
                self.state = 259
                localctx.ew = self.einheit_w()

            self.state = 263
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 262
                localctx._sst_liste_x = self.sst_liste_x()
                localctx.sst.append(localctx._sst_liste_x)
                self.state = 265
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la == dcm20Parser.T__30 or _la == dcm20Parser.T__31):
                    break

            self.state = 268
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 267
                localctx._werteliste = self.werteliste()
                localctx.wl.append(localctx._werteliste)
                self.state = 270
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la == dcm20Parser.T__10):
                    break

            self.state = 272
            self.match(dcm20Parser.T__5)
            self.state = 274
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 273
                self.match(dcm20Parser.T__0)
                self.state = 276
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la == dcm20Parser.T__0):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class KennfeldContext(ParserRuleContext):
        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.cat = None  # Token
            self.n = None  # NameValueContext
            self.ax = None  # Anzahl_xContext
            self.ay = None  # Anzahl_yContext
            self.info = None  # Kgr_infoContext
            self.ex = None  # Einheit_xContext
            self.ey = None  # Einheit_yContext
            self.ew = None  # Einheit_wContext
            self._sst_liste_x = None  # Sst_liste_xContext
            self.sst = list()  # of Sst_liste_xContexts
            self.kf = None  # Kf_zeile_listeContext

        def nameValue(self):
            return self.getTypedRuleContext(dcm20Parser.NameValueContext, 0)

        def anzahl_x(self):
            return self.getTypedRuleContext(dcm20Parser.Anzahl_xContext, 0)

        def anzahl_y(self):
            return self.getTypedRuleContext(dcm20Parser.Anzahl_yContext, 0)

        def kgr_info(self):
            return self.getTypedRuleContext(dcm20Parser.Kgr_infoContext, 0)

        def kf_zeile_liste(self):
            return self.getTypedRuleContext(dcm20Parser.Kf_zeile_listeContext, 0)

        def einheit_x(self):
            return self.getTypedRuleContext(dcm20Parser.Einheit_xContext, 0)

        def einheit_y(self):
            return self.getTypedRuleContext(dcm20Parser.Einheit_yContext, 0)

        def einheit_w(self):
            return self.getTypedRuleContext(dcm20Parser.Einheit_wContext, 0)

        def sst_liste_x(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(dcm20Parser.Sst_liste_xContext)
            else:
                return self.getTypedRuleContext(dcm20Parser.Sst_liste_xContext, i)

        def getRuleIndex(self):
            return dcm20Parser.RULE_kennfeld

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterKennfeld"):
                listener.enterKennfeld(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitKennfeld"):
                listener.exitKennfeld(self)

    def kennfeld(self):

        localctx = dcm20Parser.KennfeldContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_kennfeld)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 278
            localctx.cat = self._input.LT(1)
            _la = self._input.LA(1)
            if not (
                ((_la) & ~0x3F) == 0
                and ((1 << _la) & ((1 << dcm20Parser.T__16) | (1 << dcm20Parser.T__17) | (1 << dcm20Parser.T__18))) != 0
            ):
                localctx.cat = self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 279
            localctx.n = self.nameValue()
            self.state = 280
            localctx.ax = self.anzahl_x()
            self.state = 281
            localctx.ay = self.anzahl_y()
            self.state = 282
            self.match(dcm20Parser.T__0)
            self.state = 283
            localctx.info = self.kgr_info()
            self.state = 285
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == dcm20Parser.T__21:
                self.state = 284
                localctx.ex = self.einheit_x()

            self.state = 288
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == dcm20Parser.T__22:
                self.state = 287
                localctx.ey = self.einheit_y()

            self.state = 291
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == dcm20Parser.T__23:
                self.state = 290
                localctx.ew = self.einheit_w()

            self.state = 294
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 293
                localctx._sst_liste_x = self.sst_liste_x()
                localctx.sst.append(localctx._sst_liste_x)
                self.state = 296
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la == dcm20Parser.T__30 or _la == dcm20Parser.T__31):
                    break

            self.state = 298
            localctx.kf = self.kf_zeile_liste()
            self.state = 299
            self.match(dcm20Parser.T__5)
            self.state = 301
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 300
                self.match(dcm20Parser.T__0)
                self.state = 303
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la == dcm20Parser.T__0):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class GruppenstuetzstellenContext(ParserRuleContext):
        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.n = None  # NameValueContext
            self.nx = None  # Anzahl_xContext
            self.info = None  # Kgr_infoContext
            self.ex = None  # Einheit_xContext
            self._sst_liste_x = None  # Sst_liste_xContext
            self.sl = list()  # of Sst_liste_xContexts

        def nameValue(self):
            return self.getTypedRuleContext(dcm20Parser.NameValueContext, 0)

        def anzahl_x(self):
            return self.getTypedRuleContext(dcm20Parser.Anzahl_xContext, 0)

        def kgr_info(self):
            return self.getTypedRuleContext(dcm20Parser.Kgr_infoContext, 0)

        def einheit_x(self):
            return self.getTypedRuleContext(dcm20Parser.Einheit_xContext, 0)

        def sst_liste_x(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(dcm20Parser.Sst_liste_xContext)
            else:
                return self.getTypedRuleContext(dcm20Parser.Sst_liste_xContext, i)

        def getRuleIndex(self):
            return dcm20Parser.RULE_gruppenstuetzstellen

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterGruppenstuetzstellen"):
                listener.enterGruppenstuetzstellen(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitGruppenstuetzstellen"):
                listener.exitGruppenstuetzstellen(self)

    def gruppenstuetzstellen(self):

        localctx = dcm20Parser.GruppenstuetzstellenContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_gruppenstuetzstellen)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 305
            self.match(dcm20Parser.T__19)
            self.state = 306
            localctx.n = self.nameValue()
            self.state = 307
            localctx.nx = self.anzahl_x()
            self.state = 308
            self.match(dcm20Parser.T__0)
            self.state = 309
            localctx.info = self.kgr_info()
            self.state = 311
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == dcm20Parser.T__21:
                self.state = 310
                localctx.ex = self.einheit_x()

            self.state = 314
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 313
                localctx._sst_liste_x = self.sst_liste_x()
                localctx.sl.append(localctx._sst_liste_x)
                self.state = 316
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la == dcm20Parser.T__30 or _la == dcm20Parser.T__31):
                    break

            self.state = 318
            self.match(dcm20Parser.T__5)
            self.state = 320
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 319
                self.match(dcm20Parser.T__0)
                self.state = 322
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la == dcm20Parser.T__0):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class KenntextContext(ParserRuleContext):
        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.n = None  # NameValueContext
            self.info = None  # Kgr_infoContext
            self.t = None  # TextValueContext

        def nameValue(self):
            return self.getTypedRuleContext(dcm20Parser.NameValueContext, 0)

        def kgr_info(self):
            return self.getTypedRuleContext(dcm20Parser.Kgr_infoContext, 0)

        def textValue(self):
            return self.getTypedRuleContext(dcm20Parser.TextValueContext, 0)

        def getRuleIndex(self):
            return dcm20Parser.RULE_kenntext

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterKenntext"):
                listener.enterKenntext(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitKenntext"):
                listener.exitKenntext(self)

    def kenntext(self):

        localctx = dcm20Parser.KenntextContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_kenntext)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 324
            self.match(dcm20Parser.T__20)
            self.state = 325
            localctx.n = self.nameValue()
            self.state = 326
            self.match(dcm20Parser.T__0)
            self.state = 327
            localctx.info = self.kgr_info()
            self.state = 328
            self.match(dcm20Parser.T__11)
            self.state = 329
            localctx.t = self.textValue()
            self.state = 330
            self.match(dcm20Parser.T__0)
            self.state = 331
            self.match(dcm20Parser.T__5)
            self.state = 333
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 332
                self.match(dcm20Parser.T__0)
                self.state = 335
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la == dcm20Parser.T__0):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Kgr_infoContext(ParserRuleContext):
        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.lname = None  # LangnameContext
            self.dname = None  # DisplaynameContext
            self.var = None  # Var_abhangigkeitenContext
            self.fkt = None  # FunktionszugehorigkeitContext

        def langname(self):
            return self.getTypedRuleContext(dcm20Parser.LangnameContext, 0)

        def displayname(self):
            return self.getTypedRuleContext(dcm20Parser.DisplaynameContext, 0)

        def var_abhangigkeiten(self):
            return self.getTypedRuleContext(dcm20Parser.Var_abhangigkeitenContext, 0)

        def funktionszugehorigkeit(self):
            return self.getTypedRuleContext(dcm20Parser.FunktionszugehorigkeitContext, 0)

        def getRuleIndex(self):
            return dcm20Parser.RULE_kgr_info

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterKgr_info"):
                listener.enterKgr_info(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitKgr_info"):
                listener.exitKgr_info(self)

    def kgr_info(self):

        localctx = dcm20Parser.Kgr_infoContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_kgr_info)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 338
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == dcm20Parser.T__24:
                self.state = 337
                localctx.lname = self.langname()

            self.state = 341
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == dcm20Parser.T__25:
                self.state = 340
                localctx.dname = self.displayname()

            self.state = 344
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == dcm20Parser.T__26:
                self.state = 343
                localctx.var = self.var_abhangigkeiten()

            self.state = 347
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == dcm20Parser.T__29:
                self.state = 346
                localctx.fkt = self.funktionszugehorigkeit()

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Einheit_xContext(ParserRuleContext):
        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.t = None  # TextValueContext

        def textValue(self):
            return self.getTypedRuleContext(dcm20Parser.TextValueContext, 0)

        def getRuleIndex(self):
            return dcm20Parser.RULE_einheit_x

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterEinheit_x"):
                listener.enterEinheit_x(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitEinheit_x"):
                listener.exitEinheit_x(self)

    def einheit_x(self):

        localctx = dcm20Parser.Einheit_xContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_einheit_x)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 349
            self.match(dcm20Parser.T__21)
            self.state = 350
            localctx.t = self.textValue()
            self.state = 351
            self.match(dcm20Parser.T__0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Einheit_yContext(ParserRuleContext):
        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.t = None  # TextValueContext

        def textValue(self):
            return self.getTypedRuleContext(dcm20Parser.TextValueContext, 0)

        def getRuleIndex(self):
            return dcm20Parser.RULE_einheit_y

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterEinheit_y"):
                listener.enterEinheit_y(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitEinheit_y"):
                listener.exitEinheit_y(self)

    def einheit_y(self):

        localctx = dcm20Parser.Einheit_yContext(self, self._ctx, self.state)
        self.enterRule(localctx, 52, self.RULE_einheit_y)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 353
            self.match(dcm20Parser.T__22)
            self.state = 354
            localctx.t = self.textValue()
            self.state = 355
            self.match(dcm20Parser.T__0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Einheit_wContext(ParserRuleContext):
        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.t = None  # TextValueContext

        def textValue(self):
            return self.getTypedRuleContext(dcm20Parser.TextValueContext, 0)

        def getRuleIndex(self):
            return dcm20Parser.RULE_einheit_w

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterEinheit_w"):
                listener.enterEinheit_w(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitEinheit_w"):
                listener.exitEinheit_w(self)

    def einheit_w(self):

        localctx = dcm20Parser.Einheit_wContext(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_einheit_w)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 357
            self.match(dcm20Parser.T__23)
            self.state = 358
            localctx.t = self.textValue()
            self.state = 359
            self.match(dcm20Parser.T__0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class LangnameContext(ParserRuleContext):
        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.t = None  # TextValueContext

        def textValue(self):
            return self.getTypedRuleContext(dcm20Parser.TextValueContext, 0)

        def getRuleIndex(self):
            return dcm20Parser.RULE_langname

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterLangname"):
                listener.enterLangname(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitLangname"):
                listener.exitLangname(self)

    def langname(self):

        localctx = dcm20Parser.LangnameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 56, self.RULE_langname)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 361
            self.match(dcm20Parser.T__24)
            self.state = 362
            localctx.t = self.textValue()
            self.state = 363
            self.match(dcm20Parser.T__0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class DisplaynameContext(ParserRuleContext):
        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.n = None  # NameValueContext
            self.t = None  # TextValueContext

        def nameValue(self):
            return self.getTypedRuleContext(dcm20Parser.NameValueContext, 0)

        def textValue(self):
            return self.getTypedRuleContext(dcm20Parser.TextValueContext, 0)

        def getRuleIndex(self):
            return dcm20Parser.RULE_displayname

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterDisplayname"):
                listener.enterDisplayname(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitDisplayname"):
                listener.exitDisplayname(self)

    def displayname(self):

        localctx = dcm20Parser.DisplaynameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 58, self.RULE_displayname)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 365
            self.match(dcm20Parser.T__25)
            self.state = 368
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [dcm20Parser.NAME]:
                self.state = 366
                localctx.n = self.nameValue()
                pass
            elif token in [dcm20Parser.TEXT]:
                self.state = 367
                localctx.t = self.textValue()
                pass
            else:
                raise NoViableAltException(self)

            self.state = 370
            self.match(dcm20Parser.T__0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Var_abhangigkeitenContext(ParserRuleContext):
        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self._var_abh = None  # Var_abhContext
            self.v = list()  # of Var_abhContexts

        def var_abh(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(dcm20Parser.Var_abhContext)
            else:
                return self.getTypedRuleContext(dcm20Parser.Var_abhContext, i)

        def getRuleIndex(self):
            return dcm20Parser.RULE_var_abhangigkeiten

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterVar_abhangigkeiten"):
                listener.enterVar_abhangigkeiten(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitVar_abhangigkeiten"):
                listener.exitVar_abhangigkeiten(self)

    def var_abhangigkeiten(self):

        localctx = dcm20Parser.Var_abhangigkeitenContext(self, self._ctx, self.state)
        self.enterRule(localctx, 60, self.RULE_var_abhangigkeiten)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 372
            self.match(dcm20Parser.T__26)
            self.state = 373
            localctx._var_abh = self.var_abh()
            localctx.v.append(localctx._var_abh)
            self.state = 378
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == dcm20Parser.T__27:
                self.state = 374
                self.match(dcm20Parser.T__27)
                self.state = 375
                localctx._var_abh = self.var_abh()
                localctx.v.append(localctx._var_abh)
                self.state = 380
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 381
            self.match(dcm20Parser.T__0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Var_abhContext(ParserRuleContext):
        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.n = None  # NameValueContext

        def NAME(self):
            return self.getToken(dcm20Parser.NAME, 0)

        def nameValue(self):
            return self.getTypedRuleContext(dcm20Parser.NameValueContext, 0)

        def getRuleIndex(self):
            return dcm20Parser.RULE_var_abh

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterVar_abh"):
                listener.enterVar_abh(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitVar_abh"):
                listener.exitVar_abh(self)

    def var_abh(self):

        localctx = dcm20Parser.Var_abhContext(self, self._ctx, self.state)
        self.enterRule(localctx, 62, self.RULE_var_abh)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 383
            self.match(dcm20Parser.NAME)
            self.state = 384
            self.match(dcm20Parser.T__28)
            self.state = 385
            localctx.n = self.nameValue()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class FunktionszugehorigkeitContext(ParserRuleContext):
        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self._nameValue = None  # NameValueContext
            self.n = list()  # of NameValueContexts

        def nameValue(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(dcm20Parser.NameValueContext)
            else:
                return self.getTypedRuleContext(dcm20Parser.NameValueContext, i)

        def getRuleIndex(self):
            return dcm20Parser.RULE_funktionszugehorigkeit

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterFunktionszugehorigkeit"):
                listener.enterFunktionszugehorigkeit(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitFunktionszugehorigkeit"):
                listener.exitFunktionszugehorigkeit(self)

    def funktionszugehorigkeit(self):

        localctx = dcm20Parser.FunktionszugehorigkeitContext(self, self._ctx, self.state)
        self.enterRule(localctx, 64, self.RULE_funktionszugehorigkeit)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 387
            self.match(dcm20Parser.T__29)
            self.state = 389
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 388
                localctx._nameValue = self.nameValue()
                localctx.n.append(localctx._nameValue)
                self.state = 391
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la == dcm20Parser.NAME):
                    break

            self.state = 393
            self.match(dcm20Parser.T__0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Anzahl_xContext(ParserRuleContext):
        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.i = None  # IntegerValueContext

        def integerValue(self):
            return self.getTypedRuleContext(dcm20Parser.IntegerValueContext, 0)

        def getRuleIndex(self):
            return dcm20Parser.RULE_anzahl_x

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterAnzahl_x"):
                listener.enterAnzahl_x(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitAnzahl_x"):
                listener.exitAnzahl_x(self)

    def anzahl_x(self):

        localctx = dcm20Parser.Anzahl_xContext(self, self._ctx, self.state)
        self.enterRule(localctx, 66, self.RULE_anzahl_x)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 395
            localctx.i = self.integerValue()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Anzahl_yContext(ParserRuleContext):
        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.i = None  # IntegerValueContext

        def integerValue(self):
            return self.getTypedRuleContext(dcm20Parser.IntegerValueContext, 0)

        def getRuleIndex(self):
            return dcm20Parser.RULE_anzahl_y

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterAnzahl_y"):
                listener.enterAnzahl_y(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitAnzahl_y"):
                listener.exitAnzahl_y(self)

    def anzahl_y(self):

        localctx = dcm20Parser.Anzahl_yContext(self, self._ctx, self.state)
        self.enterRule(localctx, 68, self.RULE_anzahl_y)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 397
            localctx.i = self.integerValue()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class WertelisteContext(ParserRuleContext):
        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self._realzahl = None  # RealzahlContext
            self.r = list()  # of RealzahlContexts

        def realzahl(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(dcm20Parser.RealzahlContext)
            else:
                return self.getTypedRuleContext(dcm20Parser.RealzahlContext, i)

        def getRuleIndex(self):
            return dcm20Parser.RULE_werteliste

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterWerteliste"):
                listener.enterWerteliste(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitWerteliste"):
                listener.exitWerteliste(self)

    def werteliste(self):

        localctx = dcm20Parser.WertelisteContext(self, self._ctx, self.state)
        self.enterRule(localctx, 70, self.RULE_werteliste)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 399
            self.match(dcm20Parser.T__10)
            self.state = 401
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 400
                localctx._realzahl = self.realzahl()
                localctx.r.append(localctx._realzahl)
                self.state = 403
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la == dcm20Parser.INT or _la == dcm20Parser.FLOAT):
                    break

            self.state = 405
            self.match(dcm20Parser.T__0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Werteliste_kwbContext(ParserRuleContext):
        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self._realzahl = None  # RealzahlContext
            self.r = list()  # of RealzahlContexts
            self._textValue = None  # TextValueContext
            self.t = list()  # of TextValueContexts

        def realzahl(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(dcm20Parser.RealzahlContext)
            else:
                return self.getTypedRuleContext(dcm20Parser.RealzahlContext, i)

        def textValue(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(dcm20Parser.TextValueContext)
            else:
                return self.getTypedRuleContext(dcm20Parser.TextValueContext, i)

        def getRuleIndex(self):
            return dcm20Parser.RULE_werteliste_kwb

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterWerteliste_kwb"):
                listener.enterWerteliste_kwb(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitWerteliste_kwb"):
                listener.exitWerteliste_kwb(self)

    def werteliste_kwb(self):

        localctx = dcm20Parser.Werteliste_kwbContext(self, self._ctx, self.state)
        self.enterRule(localctx, 72, self.RULE_werteliste_kwb)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 423
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [dcm20Parser.T__10]:
                self.state = 407
                self.match(dcm20Parser.T__10)
                self.state = 409
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 408
                    localctx._realzahl = self.realzahl()
                    localctx.r.append(localctx._realzahl)
                    self.state = 411
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la == dcm20Parser.INT or _la == dcm20Parser.FLOAT):
                        break

                self.state = 413
                self.match(dcm20Parser.T__0)
                pass
            elif token in [dcm20Parser.T__11]:
                self.state = 415
                self.match(dcm20Parser.T__11)
                self.state = 417
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 416
                    localctx._textValue = self.textValue()
                    localctx.t.append(localctx._textValue)
                    self.state = 419
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la == dcm20Parser.TEXT):
                        break

                self.state = 421
                self.match(dcm20Parser.T__0)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Sst_liste_xContext(ParserRuleContext):
        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self._realzahl = None  # RealzahlContext
            self.r = list()  # of RealzahlContexts
            self._textValue = None  # TextValueContext
            self.t = list()  # of TextValueContexts

        def realzahl(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(dcm20Parser.RealzahlContext)
            else:
                return self.getTypedRuleContext(dcm20Parser.RealzahlContext, i)

        def textValue(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(dcm20Parser.TextValueContext)
            else:
                return self.getTypedRuleContext(dcm20Parser.TextValueContext, i)

        def getRuleIndex(self):
            return dcm20Parser.RULE_sst_liste_x

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterSst_liste_x"):
                listener.enterSst_liste_x(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitSst_liste_x"):
                listener.exitSst_liste_x(self)

    def sst_liste_x(self):

        localctx = dcm20Parser.Sst_liste_xContext(self, self._ctx, self.state)
        self.enterRule(localctx, 74, self.RULE_sst_liste_x)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 441
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [dcm20Parser.T__30]:
                self.state = 425
                self.match(dcm20Parser.T__30)
                self.state = 427
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 426
                    localctx._realzahl = self.realzahl()
                    localctx.r.append(localctx._realzahl)
                    self.state = 429
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la == dcm20Parser.INT or _la == dcm20Parser.FLOAT):
                        break

                self.state = 431
                self.match(dcm20Parser.T__0)
                pass
            elif token in [dcm20Parser.T__31]:
                self.state = 433
                self.match(dcm20Parser.T__31)
                self.state = 435
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 434
                    localctx._textValue = self.textValue()
                    localctx.t.append(localctx._textValue)
                    self.state = 437
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la == dcm20Parser.TEXT):
                        break

                self.state = 439
                self.match(dcm20Parser.T__0)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Kf_zeile_listeContext(ParserRuleContext):
        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self._kf_zeile_liste_r = None  # Kf_zeile_liste_rContext
            self.r = list()  # of Kf_zeile_liste_rContexts
            self._kf_zeile_liste_tx = None  # Kf_zeile_liste_txContext
            self.t = list()  # of Kf_zeile_liste_txContexts

        def kf_zeile_liste_r(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(dcm20Parser.Kf_zeile_liste_rContext)
            else:
                return self.getTypedRuleContext(dcm20Parser.Kf_zeile_liste_rContext, i)

        def kf_zeile_liste_tx(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(dcm20Parser.Kf_zeile_liste_txContext)
            else:
                return self.getTypedRuleContext(dcm20Parser.Kf_zeile_liste_txContext, i)

        def getRuleIndex(self):
            return dcm20Parser.RULE_kf_zeile_liste

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterKf_zeile_liste"):
                listener.enterKf_zeile_liste(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitKf_zeile_liste"):
                listener.exitKf_zeile_liste(self)

    def kf_zeile_liste(self):

        localctx = dcm20Parser.Kf_zeile_listeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 76, self.RULE_kf_zeile_liste)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 453
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [dcm20Parser.T__32]:
                self.state = 444
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 443
                    localctx._kf_zeile_liste_r = self.kf_zeile_liste_r()
                    localctx.r.append(localctx._kf_zeile_liste_r)
                    self.state = 446
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la == dcm20Parser.T__32):
                        break

                pass
            elif token in [dcm20Parser.T__33]:
                self.state = 449
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 448
                    localctx._kf_zeile_liste_tx = self.kf_zeile_liste_tx()
                    localctx.t.append(localctx._kf_zeile_liste_tx)
                    self.state = 451
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la == dcm20Parser.T__33):
                        break

                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Kf_zeile_liste_rContext(ParserRuleContext):
        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.r = None  # RealzahlContext
            self._werteliste = None  # WertelisteContext
            self.w = list()  # of WertelisteContexts

        def realzahl(self):
            return self.getTypedRuleContext(dcm20Parser.RealzahlContext, 0)

        def werteliste(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(dcm20Parser.WertelisteContext)
            else:
                return self.getTypedRuleContext(dcm20Parser.WertelisteContext, i)

        def getRuleIndex(self):
            return dcm20Parser.RULE_kf_zeile_liste_r

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterKf_zeile_liste_r"):
                listener.enterKf_zeile_liste_r(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitKf_zeile_liste_r"):
                listener.exitKf_zeile_liste_r(self)

    def kf_zeile_liste_r(self):

        localctx = dcm20Parser.Kf_zeile_liste_rContext(self, self._ctx, self.state)
        self.enterRule(localctx, 78, self.RULE_kf_zeile_liste_r)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 455
            self.match(dcm20Parser.T__32)
            self.state = 456
            localctx.r = self.realzahl()
            self.state = 457
            self.match(dcm20Parser.T__0)
            self.state = 459
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 458
                localctx._werteliste = self.werteliste()
                localctx.w.append(localctx._werteliste)
                self.state = 461
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la == dcm20Parser.T__10):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Kf_zeile_liste_txContext(ParserRuleContext):
        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.t = None  # TextValueContext
            self._werteliste = None  # WertelisteContext
            self.w = list()  # of WertelisteContexts

        def textValue(self):
            return self.getTypedRuleContext(dcm20Parser.TextValueContext, 0)

        def werteliste(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(dcm20Parser.WertelisteContext)
            else:
                return self.getTypedRuleContext(dcm20Parser.WertelisteContext, i)

        def getRuleIndex(self):
            return dcm20Parser.RULE_kf_zeile_liste_tx

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterKf_zeile_liste_tx"):
                listener.enterKf_zeile_liste_tx(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitKf_zeile_liste_tx"):
                listener.exitKf_zeile_liste_tx(self)

    def kf_zeile_liste_tx(self):

        localctx = dcm20Parser.Kf_zeile_liste_txContext(self, self._ctx, self.state)
        self.enterRule(localctx, 80, self.RULE_kf_zeile_liste_tx)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 463
            self.match(dcm20Parser.T__33)
            self.state = 464
            localctx.t = self.textValue()
            self.state = 465
            self.match(dcm20Parser.T__0)
            self.state = 467
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 466
                localctx._werteliste = self.werteliste()
                localctx.w.append(localctx._werteliste)
                self.state = 469
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la == dcm20Parser.T__10):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class RealzahlContext(ParserRuleContext):
        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.i = None  # Token
            self.f = None  # Token

        def INT(self):
            return self.getToken(dcm20Parser.INT, 0)

        def FLOAT(self):
            return self.getToken(dcm20Parser.FLOAT, 0)

        def getRuleIndex(self):
            return dcm20Parser.RULE_realzahl

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterRealzahl"):
                listener.enterRealzahl(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitRealzahl"):
                listener.exitRealzahl(self)

    def realzahl(self):

        localctx = dcm20Parser.RealzahlContext(self, self._ctx, self.state)
        self.enterRule(localctx, 82, self.RULE_realzahl)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 473
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [dcm20Parser.INT]:
                self.state = 471
                localctx.i = self.match(dcm20Parser.INT)
                pass
            elif token in [dcm20Parser.FLOAT]:
                self.state = 472
                localctx.f = self.match(dcm20Parser.FLOAT)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class NameValueContext(ParserRuleContext):
        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.n = None  # Token

        def NAME(self):
            return self.getToken(dcm20Parser.NAME, 0)

        def getRuleIndex(self):
            return dcm20Parser.RULE_nameValue

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterNameValue"):
                listener.enterNameValue(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitNameValue"):
                listener.exitNameValue(self)

    def nameValue(self):

        localctx = dcm20Parser.NameValueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 84, self.RULE_nameValue)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 475
            localctx.n = self.match(dcm20Parser.NAME)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class TextValueContext(ParserRuleContext):
        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.t = None  # Token

        def TEXT(self):
            return self.getToken(dcm20Parser.TEXT, 0)

        def getRuleIndex(self):
            return dcm20Parser.RULE_textValue

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterTextValue"):
                listener.enterTextValue(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitTextValue"):
                listener.exitTextValue(self)

    def textValue(self):

        localctx = dcm20Parser.TextValueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 86, self.RULE_textValue)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 477
            localctx.t = self.match(dcm20Parser.TEXT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class IntegerValueContext(ParserRuleContext):
        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.i = None  # Token

        def INT(self):
            return self.getToken(dcm20Parser.INT, 0)

        def getRuleIndex(self):
            return dcm20Parser.RULE_integerValue

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterIntegerValue"):
                listener.enterIntegerValue(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitIntegerValue"):
                listener.exitIntegerValue(self)

    def integerValue(self):

        localctx = dcm20Parser.IntegerValueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 88, self.RULE_integerValue)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 479
            localctx.i = self.match(dcm20Parser.INT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx
